////
//  Copyright ⓒ 2018-2019 ThePhD.
//
//  Distributed under the Boost Software License, Version 1.0. (See
//  accompanying file LICENSE or copy at
//  http://www.boost.org/LICENSE_1_0.txt)
//
//  See http://www.boost.org/libs/out_ptr/ for documentation.
////

# phd.out_ptr at a glance

Have you ever wanted to pass a smart pointer like `std::unique_ptr` or `boost::shared_ptr` or `phd::intrusive_ptr` to a C API?

```
boost::shared_ptr<mll_driver> axis_driver;
mll_errno err = mll_driver_init(&axis_driver, 
	/* additional args ...*/);
if (err != MLL_SUCESS) {
	// ...
}
```

The above code doesn't compile: the pointer may be "smart", but it isn't smart enough to return a `mll_driver**` when you do `&axis_driver` on it. It also makes it hard to retain the current deleter with a `shared_ptr`.

### So, try raw pointers?

Downgrading to a raw pointer and then inserting it into the pointer works, but is more verbose:

```
boost::shared_ptr<mll_driver> axis_driver;
mll_driver* raw_axis_driver = nullptr;
mll_errno err = mll_driver_init(&raw_axis_driver, 
	/* additional args ...*/);
if (err != MLL_SUCESS) {
	// ...
}
axis_driver.reset(raw_axis_driver, mll_driver_free);
```

This works, but you need to call `.reset(...)` with the raw pointer and set everything up. Plus, there could be a lot of error handling code between us and the actual initialization call. Not to mention a thrown exception between the end of that call and `axis_driver.reset(...);` means you may have a leak.

### Let's make it simple and easy!

With phd.out_ptr, we can do better. Get rid of the raw pointer and avoid potential memory or resource leakage by using this https://en.cppreference.com/w/cpp/language/raii[RAII] function:

```
using bop = phd::out_ptr;

boost::shared_ptr<mll_driver> axis_driver(nullptr);
mll_errno err = mll_driver_init(bop::out_ptr(axis_driver, mll_driver_free), 
	/* additional args ...*/);
if (err != MLL_SUCESS) {
	// ...
}
```

No reset call, no inspecting for exception safety, and it remembers the deleter we passed in after `axis_driver` to safely and properly call `.reset()` for shared pointers that stores the deleter.

Welcome to phd.out_ptr, the present and future of C API interoperation. This library automates the `.reset(...)` and -- sometimes additionally -- the `.release()` call when interfacing with C-style initialization functions which take an "output parameter" of `$$T**$$`.

- Use <<reference/out_ptr.adoc#ref.out_ptr.function, `phd::out_ptr::out_ptr`>> when you just need to call `.reset()`, or use <<reference/inout_ptr.adoc#ref.inout_ptr.function, `phd::out_ptr::inout_ptr`>>, when you need to call `.release()` and then `.reset()` (e.g., for a reallocating C function).
- Get started with the <<examples.adoc#examples,examples>>.
- Understand the pitfalls and problems that come with {cpp} and phd.out_ptr by reading <<caveats.adoc#caveats, the Caveats>>.
- Read up on how to use it with your <<customization.adoc#customization, custom smart pointers>>, if you do not have a conforming interface!
- The exact interface requirements on the desired smart pointers can be seen in the <<reference.adoc#ref.api, reference documentation for the types produced by the factory functions>>.
- Peruse & use the advanced <<config.adoc#config, configuration options>> for safety, sanity checking, and speed!

C APIs might not be fun, but at least working with the pointers should feel easy and safe and simple!

Happy programming. ♥
